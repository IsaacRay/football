"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/supabaseQueries.ts":
/*!************************************!*\
  !*** ./app/lib/supabaseQueries.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPlayerForCurrentUser: () => (/* binding */ createPlayerForCurrentUser),\n/* harmony export */   getAllTeams: () => (/* binding */ getAllTeams),\n/* harmony export */   getAvailableTeams: () => (/* binding */ getAvailableTeams),\n/* harmony export */   getCurrentUserPlayer: () => (/* binding */ getCurrentUserPlayer),\n/* harmony export */   getDefaultPool: () => (/* binding */ getDefaultPool),\n/* harmony export */   getGamesByWeek: () => (/* binding */ getGamesByWeek),\n/* harmony export */   getPicksByPlayer: () => (/* binding */ getPicksByPlayer),\n/* harmony export */   getPlayersByPool: () => (/* binding */ getPlayersByPool),\n/* harmony export */   submitPick: () => (/* binding */ submitPick),\n/* harmony export */   updateGameWinner: () => (/* binding */ updateGameWinner)\n/* harmony export */ });\n/* harmony import */ var _utils_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/supabase/client */ \"(app-pages-browser)/./app/utils/supabase/client.ts\");\n\nconst supabase = (0,_utils_supabase_client__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n// Teams\nasync function getAllTeams() {\n    const { data, error } = await supabase.from('teams').select('*').order('name');\n    if (error) {\n        console.error('Error fetching teams:', error);\n        return [];\n    }\n    return data || [];\n}\n// Games\nasync function getGamesByWeek(week) {\n    let season = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2025;\n    const { data, error } = await supabase.from('games').select('*').eq('season', season).eq('week_number', week).order('game_time');\n    if (error) {\n        console.error('Error fetching games:', error);\n        return [];\n    }\n    return data || [];\n}\n// Update game winner (Admin function)\nasync function updateGameWinner(gameId, winnerId) {\n    const { error } = await supabase.from('games').update({\n        winner: winnerId,\n        is_complete: winnerId !== null,\n        updated_at: new Date().toISOString()\n    }).eq('id', gameId);\n    if (error) {\n        return false;\n    }\n    return true;\n}\n// Players\nasync function getPlayersByPool(poolId) {\n    const { data, error } = await supabase.from('players').select('*').eq('pool_id', poolId).order('lives_remaining', {\n        ascending: false\n    }).order('display_name');\n    if (error) {\n        console.error('Error fetching players:', error);\n        return [];\n    }\n    return data || [];\n}\nasync function getCurrentUserPlayer(poolId) {\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data, error } = await supabase.from('players').select('*').eq('pool_id', poolId).eq('user_id', user.id).single();\n    if (error) {\n        console.error('Error fetching current user player:', error);\n        return null;\n    }\n    return data;\n}\n// Picks\nasync function getPicksByPlayer(playerId) {\n    const { data, error } = await supabase.from('picks').select('*').eq('player_id', playerId).order('week_number');\n    if (error) {\n        console.error('Error fetching picks:', error);\n        return [];\n    }\n    return data || [];\n}\nasync function submitPick(pick) {\n    const { error } = await supabase.from('picks').insert(pick);\n    if (error) {\n        console.error('Error submitting pick:', error);\n        return false;\n    }\n    return true;\n}\n// Pools\nasync function getDefaultPool() {\n    const { data, error } = await supabase.from('pools').select('*').eq('is_active', true).order('created_at', {\n        ascending: false\n    }).limit(1).single();\n    if (error) {\n        console.error('Error fetching default pool:', error);\n        return null;\n    }\n    return data;\n}\nasync function createPlayerForCurrentUser(poolId, displayName) {\n    var _user_email;\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data, error } = await supabase.from('players').insert({\n        pool_id: poolId,\n        user_id: user.id,\n        display_name: displayName || ((_user_email = user.email) === null || _user_email === void 0 ? void 0 : _user_email.split('@')[0]) || 'Player',\n        lives_remaining: 3,\n        is_eliminated: false\n    }).select().single();\n    if (error) {\n        console.error('Error creating player:', error);\n        return null;\n    }\n    return data;\n}\n// Available teams for a player (teams not yet used)\nasync function getAvailableTeams(playerId) {\n    // Get all teams\n    const allTeams = await getAllTeams();\n    // Get player's picks\n    const picks = await getPicksByPlayer(playerId);\n    const usedTeamIds = picks.map((pick)=>pick.team_id);\n    // Filter out used teams\n    return allTeams.filter((team)=>!usedTeamIds.includes(team.id));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvc3VwYWJhc2VRdWVyaWVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBU3hELE1BQU1DLFdBQVdELG9FQUFZQTtBQUU3QixRQUFRO0FBQ0QsZUFBZUU7SUFDcEIsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1ILFNBQzNCSSxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDLEtBQ1BDLEtBQUssQ0FBQztJQUVULElBQUlILE9BQU87UUFDVEksUUFBUUosS0FBSyxDQUFDLHlCQUF5QkE7UUFDdkMsT0FBTyxFQUFFO0lBQ1g7SUFFQSxPQUFPRCxRQUFRLEVBQUU7QUFDbkI7QUFFQSxRQUFRO0FBQ0QsZUFBZU0sZUFBZUMsSUFBWTtRQUFFQyxTQUFBQSxpRUFBUztJQUMxRCxNQUFNLEVBQUVSLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUgsU0FDM0JJLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsS0FDUE0sRUFBRSxDQUFDLFVBQVVELFFBQ2JDLEVBQUUsQ0FBQyxlQUFlRixNQUNsQkgsS0FBSyxDQUFDO0lBRVQsSUFBSUgsT0FBTztRQUNUSSxRQUFRSixLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxPQUFPLEVBQUU7SUFDWDtJQUVBLE9BQU9ELFFBQVEsRUFBRTtBQUNuQjtBQUVBLHNDQUFzQztBQUMvQixlQUFlVSxpQkFBaUJDLE1BQWMsRUFBRUMsUUFBdUI7SUFDNUUsTUFBTSxFQUFFWCxLQUFLLEVBQUUsR0FBRyxNQUFNSCxTQUNyQkksSUFBSSxDQUFDLFNBQ0xXLE1BQU0sQ0FBQztRQUNOQyxRQUFRRjtRQUNSRyxhQUFhSCxhQUFhO1FBQzFCSSxZQUFZLElBQUlDLE9BQU9DLFdBQVc7SUFDcEMsR0FDQ1QsRUFBRSxDQUFDLE1BQU1FO0lBRVosSUFBSVYsT0FBTztRQUNULE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVBLFVBQVU7QUFDSCxlQUFl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QTtRQUN4QyxPQUFPO0lBQ1Q7SUFFQSxPQUFPRDtBQUNUO0FBRUEsb0RBQW9EO0FBQzdDLGVBQWU0QyxrQkFBa0JmLFFBQWdCO0lBQ3RELGdCQUFnQjtJQUNoQixNQUFNZ0IsV0FBVyxNQUFNOUM7SUFFdkIscUJBQXFCO0lBQ3JCLE1BQU0rQyxRQUFRLE1BQU1sQixpQkFBaUJDO0lBQ3JDLE1BQU1rQixjQUFjRCxNQUFNRSxHQUFHLENBQUNqQixDQUFBQSxPQUFRQSxLQUFLa0IsT0FBTztJQUVsRCx3QkFBd0I7SUFDeEIsT0FBT0osU0FBU0ssTUFBTSxDQUFDQyxDQUFBQSxPQUFRLENBQUNKLFlBQVlLLFFBQVEsQ0FBQ0QsS0FBS3pCLEVBQUU7QUFDOUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2FhY3JheS9EZXNrdG9wL2Zvb3RiYWxsL2FwcC9saWIvc3VwYWJhc2VRdWVyaWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJy4uL3V0aWxzL3N1cGFiYXNlL2NsaWVudCc7XG5pbXBvcnQgeyBEYXRhYmFzZSB9IGZyb20gJy4vc3VwYWJhc2UnO1xuXG5leHBvcnQgdHlwZSBUZWFtID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsndGVhbXMnXVsnUm93J107XG5leHBvcnQgdHlwZSBHYW1lID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsnZ2FtZXMnXVsnUm93J107XG5leHBvcnQgdHlwZSBQbGF5ZXIgPSBEYXRhYmFzZVsncHVibGljJ11bJ1RhYmxlcyddWydwbGF5ZXJzJ11bJ1JvdyddO1xuZXhwb3J0IHR5cGUgUGljayA9IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ3BpY2tzJ11bJ1JvdyddO1xuZXhwb3J0IHR5cGUgUG9vbCA9IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ3Bvb2xzJ11bJ1JvdyddO1xuXG5jb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudCgpO1xuXG4vLyBUZWFtc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFRlYW1zKCk6IFByb21pc2U8VGVhbVtdPiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3RlYW1zJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAub3JkZXIoJ25hbWUnKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRlYW1zOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG4vLyBHYW1lc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEdhbWVzQnlXZWVrKHdlZWs6IG51bWJlciwgc2Vhc29uID0gMjAyNSk6IFByb21pc2U8R2FtZVtdPiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2dhbWVzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ3NlYXNvbicsIHNlYXNvbilcbiAgICAuZXEoJ3dlZWtfbnVtYmVyJywgd2VlaylcbiAgICAub3JkZXIoJ2dhbWVfdGltZScpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZ2FtZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBcbiAgcmV0dXJuIGRhdGEgfHwgW107XG59XG5cbi8vIFVwZGF0ZSBnYW1lIHdpbm5lciAoQWRtaW4gZnVuY3Rpb24pXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlR2FtZVdpbm5lcihnYW1lSWQ6IHN0cmluZywgd2lubmVySWQ6IHN0cmluZyB8IG51bGwpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnZ2FtZXMnKVxuICAgIC51cGRhdGUoeyBcbiAgICAgIHdpbm5lcjogd2lubmVySWQsXG4gICAgICBpc19jb21wbGV0ZTogd2lubmVySWQgIT09IG51bGwsXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9KVxuICAgIC5lcSgnaWQnLCBnYW1lSWQpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUGxheWVyc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBsYXllcnNCeVBvb2wocG9vbElkOiBzdHJpbmcpOiBQcm9taXNlPFBsYXllcltdPiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BsYXllcnMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgncG9vbF9pZCcsIHBvb2xJZClcbiAgICAub3JkZXIoJ2xpdmVzX3JlbWFpbmluZycsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgIC5vcmRlcignZGlzcGxheV9uYW1lJyk7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwbGF5ZXJzOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXJQbGF5ZXIocG9vbElkOiBzdHJpbmcpOiBQcm9taXNlPFBsYXllciB8IG51bGw+IHtcbiAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gIFxuICBpZiAoIXVzZXIpIHJldHVybiBudWxsO1xuICBcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncGxheWVycycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdwb29sX2lkJywgcG9vbElkKVxuICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgLnNpbmdsZSgpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY3VycmVudCB1c2VyIHBsYXllcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhO1xufVxuXG4vLyBQaWNrc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBpY2tzQnlQbGF5ZXIocGxheWVySWQ6IHN0cmluZyk6IFByb21pc2U8UGlja1tdPiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BpY2tzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ3BsYXllcl9pZCcsIHBsYXllcklkKVxuICAgIC5vcmRlcignd2Vla19udW1iZXInKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHBpY2tzOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3VibWl0UGljayhwaWNrOiBPbWl0PFBpY2ssICdpZCcgfCAnY3JlYXRlZF9hdCcgfCAndXBkYXRlZF9hdCc+KTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BpY2tzJylcbiAgICAuaW5zZXJ0KHBpY2spO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3VibWl0dGluZyBwaWNrOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBQb29sc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERlZmF1bHRQb29sKCk6IFByb21pc2U8UG9vbCB8IG51bGw+IHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncG9vbHMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAubGltaXQoMSlcbiAgICAuc2luZ2xlKCk7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkZWZhdWx0IHBvb2w6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVBsYXllckZvckN1cnJlbnRVc2VyKHBvb2xJZDogc3RyaW5nLCBkaXNwbGF5TmFtZT86IHN0cmluZyk6IFByb21pc2U8UGxheWVyIHwgbnVsbD4ge1xuICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgXG4gIGlmICghdXNlcikgcmV0dXJuIG51bGw7XG4gIFxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdwbGF5ZXJzJylcbiAgICAuaW5zZXJ0KHtcbiAgICAgIHBvb2xfaWQ6IHBvb2xJZCxcbiAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICBkaXNwbGF5X25hbWU6IGRpc3BsYXlOYW1lIHx8IHVzZXIuZW1haWw/LnNwbGl0KCdAJylbMF0gfHwgJ1BsYXllcicsXG4gICAgICBsaXZlc19yZW1haW5pbmc6IDMsXG4gICAgICBpc19lbGltaW5hdGVkOiBmYWxzZSxcbiAgICB9KVxuICAgIC5zZWxlY3QoKVxuICAgIC5zaW5nbGUoKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBsYXllcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhO1xufVxuXG4vLyBBdmFpbGFibGUgdGVhbXMgZm9yIGEgcGxheWVyICh0ZWFtcyBub3QgeWV0IHVzZWQpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlVGVhbXMocGxheWVySWQ6IHN0cmluZyk6IFByb21pc2U8VGVhbVtdPiB7XG4gIC8vIEdldCBhbGwgdGVhbXNcbiAgY29uc3QgYWxsVGVhbXMgPSBhd2FpdCBnZXRBbGxUZWFtcygpO1xuICBcbiAgLy8gR2V0IHBsYXllcidzIHBpY2tzXG4gIGNvbnN0IHBpY2tzID0gYXdhaXQgZ2V0UGlja3NCeVBsYXllcihwbGF5ZXJJZCk7XG4gIGNvbnN0IHVzZWRUZWFtSWRzID0gcGlja3MubWFwKHBpY2sgPT4gcGljay50ZWFtX2lkKTtcbiAgXG4gIC8vIEZpbHRlciBvdXQgdXNlZCB0ZWFtc1xuICByZXR1cm4gYWxsVGVhbXMuZmlsdGVyKHRlYW0gPT4gIXVzZWRUZWFtSWRzLmluY2x1ZGVzKHRlYW0uaWQpKTtcbn0iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2UiLCJnZXRBbGxUZWFtcyIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImNvbnNvbGUiLCJnZXRHYW1lc0J5V2VlayIsIndlZWsiLCJzZWFzb24iLCJlcSIsInVwZGF0ZUdhbWVXaW5uZXIiLCJnYW1lSWQiLCJ3aW5uZXJJZCIsInVwZGF0ZSIsIndpbm5lciIsImlzX2NvbXBsZXRlIiwidXBkYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImdldFBsYXllcnNCeVBvb2wiLCJwb29sSWQiLCJhc2NlbmRpbmciLCJnZXRDdXJyZW50VXNlclBsYXllciIsInVzZXIiLCJhdXRoIiwiZ2V0VXNlciIsImlkIiwic2luZ2xlIiwiZ2V0UGlja3NCeVBsYXllciIsInBsYXllcklkIiwic3VibWl0UGljayIsInBpY2siLCJpbnNlcnQiLCJnZXREZWZhdWx0UG9vbCIsImxpbWl0IiwiY3JlYXRlUGxheWVyRm9yQ3VycmVudFVzZXIiLCJkaXNwbGF5TmFtZSIsInBvb2xfaWQiLCJ1c2VyX2lkIiwiZGlzcGxheV9uYW1lIiwiZW1haWwiLCJzcGxpdCIsImxpdmVzX3JlbWFpbmluZyIsImlzX2VsaW1pbmF0ZWQiLCJnZXRBdmFpbGFibGVUZWFtcyIsImFsbFRlYW1zIiwicGlja3MiLCJ1c2VkVGVhbUlkcyIsIm1hcCIsInRlYW1faWQiLCJmaWx0ZXIiLCJ0ZWFtIiwiaW5jbHVkZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/supabaseQueries.ts\n"));

/***/ })

});