"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/supabaseQueries.ts":
/*!************************************!*\
  !*** ./app/lib/supabaseQueries.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canEditPicks: () => (/* binding */ canEditPicks),\n/* harmony export */   createPlayerForCurrentUser: () => (/* binding */ createPlayerForCurrentUser),\n/* harmony export */   getAllTeams: () => (/* binding */ getAllTeams),\n/* harmony export */   getAvailableTeams: () => (/* binding */ getAvailableTeams),\n/* harmony export */   getCurrentUserPlayer: () => (/* binding */ getCurrentUserPlayer),\n/* harmony export */   getDefaultPool: () => (/* binding */ getDefaultPool),\n/* harmony export */   getExistingPick: () => (/* binding */ getExistingPick),\n/* harmony export */   getGamesByWeek: () => (/* binding */ getGamesByWeek),\n/* harmony export */   getPicksByPlayer: () => (/* binding */ getPicksByPlayer),\n/* harmony export */   getPlayersByPool: () => (/* binding */ getPlayersByPool),\n/* harmony export */   submitPick: () => (/* binding */ submitPick),\n/* harmony export */   updateGameWinner: () => (/* binding */ updateGameWinner),\n/* harmony export */   updatePick: () => (/* binding */ updatePick)\n/* harmony export */ });\n/* harmony import */ var _utils_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/supabase/client */ \"(app-pages-browser)/./app/utils/supabase/client.ts\");\n\nconst supabase = (0,_utils_supabase_client__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n// Teams\nasync function getAllTeams() {\n    const { data, error } = await supabase.from('teams').select('*').order('name');\n    if (error) {\n        return [];\n    }\n    return data || [];\n}\n// Games\nasync function getGamesByWeek(week) {\n    let season = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2025;\n    const { data, error } = await supabase.from('games').select('*').eq('season', season).eq('week_number', week).order('game_time');\n    if (error) {\n        return [];\n    }\n    return data || [];\n}\n// Update game winner (Admin function)\nasync function updateGameWinner(gameId, winnerId) {\n    const { error } = await supabase.from('games').update({\n        winner: winnerId,\n        is_complete: winnerId !== null,\n        updated_at: new Date().toISOString()\n    }).eq('id', gameId);\n    if (error) {\n        return false;\n    }\n    return true;\n}\n// Players\nasync function getPlayersByPool(poolId) {\n    const { data, error } = await supabase.from('players').select('*').eq('pool_id', poolId).order('lives_remaining', {\n        ascending: false\n    }).order('display_name');\n    if (error) {\n        return [];\n    }\n    return data || [];\n}\nasync function getCurrentUserPlayer(poolId) {\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data, error } = await supabase.from('players').select('*').eq('pool_id', poolId).eq('user_id', user.id).single();\n    if (error) {\n        return null;\n    }\n    return data;\n}\n// Picks\nasync function getPicksByPlayer(playerId) {\n    const { data, error } = await supabase.from('picks').select('*').eq('player_id', playerId).order('week_number');\n    if (error) {\n        return [];\n    }\n    return data || [];\n}\nasync function submitPick(pick) {\n    const { error } = await supabase.from('picks').insert(pick);\n    if (error) {\n        return false;\n    }\n    return true;\n}\n// Update existing pick\nasync function updatePick(playerId, weekNumber, teamId) {\n    const { error } = await supabase.from('picks').update({\n        team_id: teamId,\n        updated_at: new Date().toISOString()\n    }).eq('player_id', playerId).eq('week_number', weekNumber);\n    if (error) {\n        return false;\n    }\n    return true;\n}\n// Get existing pick for a player and week\nasync function getExistingPick(playerId, weekNumber) {\n    const { data, error } = await supabase.from('picks').select('*').eq('player_id', playerId).eq('week_number', weekNumber).single();\n    if (error) {\n        return null;\n    }\n    return data;\n}\n// Check if picks can still be edited (before first game of week starts)\nasync function canEditPicks(weekNumber) {\n    let season = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2025;\n    const { data, error } = await supabase.from('games').select('game_time').eq('season', season).eq('week_number', weekNumber).order('game_time').limit(1).single();\n    if (error || !data) {\n        return false;\n    }\n    const firstGameTime = new Date(data.game_time);\n    const now = new Date();\n    return now < firstGameTime;\n}\n// Pools\nasync function getDefaultPool() {\n    const { data, error } = await supabase.from('pools').select('*').eq('is_active', true).order('created_at', {\n        ascending: false\n    }).limit(1).single();\n    if (error) {\n        return null;\n    }\n    return data;\n}\nasync function createPlayerForCurrentUser(poolId, displayName) {\n    var _user_email;\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data, error } = await supabase.from('players').insert({\n        pool_id: poolId,\n        user_id: user.id,\n        display_name: displayName || ((_user_email = user.email) === null || _user_email === void 0 ? void 0 : _user_email.split('@')[0]) || 'Player',\n        lives_remaining: 3,\n        is_eliminated: false\n    }).select().single();\n    if (error) {\n        return null;\n    }\n    return data;\n}\n// Available teams for a player (teams not yet used)\nasync function getAvailableTeams(playerId) {\n    // Get all teams\n    const allTeams = await getAllTeams();\n    // Get player's picks\n    const picks = await getPicksByPlayer(playerId);\n    const usedTeamIds = picks.map((pick)=>pick.team_id);\n    // Filter out used teams\n    return allTeams.filter((team)=>!usedTeamIds.includes(team.id));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvc3VwYWJhc2VRdWVyaWVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBU3hELE1BQU1DLFdBQVdELG9FQUFZQTtBQUU3QixRQUFRO0FBQ0QsZUFBZUU7SUFDcEIsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1ILFNBQzNCSSxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDLEtBQ1BDLEtBQUssQ0FBQztJQUVULElBQUlILE9BQU87UUFDVCxPQUFPLEVBQUU7SUFDWDtJQUVBLE9BQU9ELFFBQVEsRUFBRTtBQUNuQjtBQUVBLFFBQVE7QUFDRCxlQUFlSyxlQUFlQyxJQUFZO1FBQUVDLFNBQUFBLGlFQUFTO0lBQzFELE1BQU0sRUFBRVAsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNSCxTQUMzQkksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxLQUNQSyxFQUFFLENBQUMsVUFBVUQsUUFDYkMsRUFBRSxDQUFDLGVBQWVGLE1BQ2xCRixLQUFLLENBQUM7SUFFVCxJQUFJSCxPQUFPO1FBQ1QsT0FBTyxFQUFFO0lBQ1g7SUFFQSxPQUFPRCxRQUFRLEVBQUU7QUFDbkI7QUFFQSxzQ0FBc0M7QUFDL0IsZUFBZVMsaUJBQWlCQyxNQUFjLEVBQUVDLFFBQXVCO0lBQzVFLE1BQU0sRUFBRVYsS0FBSyxFQUFFLEdBQUcsTUFBTUgsU0FDckJJLElBQUksQ0FBQyxTQUNMVSxNQUFNLENBQUM7UUFDTkMsUUFBUUY7UUFDUkcsYUFBYUgsYUFBYTtRQUMxQkksWUFBWSxJQUFJQyxPQUFPQyxXQUFXO0lBQ3BDLEdBQ0NULEVBQUUsQ0FBQyxNQUFNRTtJQUVaLElBQUlULE9BQU87UUFDVCxPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxVQUFVO0FBQ0gsZUFBZWlCLGlCQUFpQkMsTUFBYztJQUNuRCxNQUFNLEVBQUVuQixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFH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QUNDLENBQUFBLE9BQVEsQ0FBQ0gsWUFBWUksUUFBUSxDQUFDRCxLQUFLakMsRUFBRTtBQUM5RCIsInNvdXJjZXMiOlsiL1VzZXJzL2lzYWFjcmF5L0Rlc2t0b3AvZm9vdGJhbGwvYXBwL2xpYi9zdXBhYmFzZVF1ZXJpZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnLi4vdXRpbHMvc3VwYWJhc2UvY2xpZW50JztcbmltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZSc7XG5cbmV4cG9ydCB0eXBlIFRlYW0gPSBEYXRhYmFzZVsncHVibGljJ11bJ1RhYmxlcyddWyd0ZWFtcyddWydSb3cnXTtcbmV4cG9ydCB0eXBlIEdhbWUgPSBEYXRhYmFzZVsncHVibGljJ11bJ1RhYmxlcyddWydnYW1lcyddWydSb3cnXTtcbmV4cG9ydCB0eXBlIFBsYXllciA9IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ3BsYXllcnMnXVsnUm93J107XG5leHBvcnQgdHlwZSBQaWNrID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsncGlja3MnXVsnUm93J107XG5leHBvcnQgdHlwZSBQb29sID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsncG9vbHMnXVsnUm93J107XG5cbmNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCk7XG5cbi8vIFRlYW1zXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsVGVhbXMoKTogUHJvbWlzZTxUZWFtW10+IHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgndGVhbXMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5vcmRlcignbmFtZScpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIFxuICByZXR1cm4gZGF0YSB8fCBbXTtcbn1cblxuLy8gR2FtZXNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRHYW1lc0J5V2Vlayh3ZWVrOiBudW1iZXIsIHNlYXNvbiA9IDIwMjUpOiBQcm9taXNlPEdhbWVbXT4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdnYW1lcycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdzZWFzb24nLCBzZWFzb24pXG4gICAgLmVxKCd3ZWVrX251bWJlcicsIHdlZWspXG4gICAgLm9yZGVyKCdnYW1lX3RpbWUnKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBcbiAgcmV0dXJuIGRhdGEgfHwgW107XG59XG5cbi8vIFVwZGF0ZSBnYW1lIHdpbm5lciAoQWRtaW4gZnVuY3Rpb24pXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlR2FtZVdpbm5lcihnYW1lSWQ6IHN0cmluZywgd2lubmVySWQ6IHN0cmluZyB8IG51bGwpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnZ2FtZXMnKVxuICAgIC51cGRhdGUoeyBcbiAgICAgIHdpbm5lcjogd2lubmVySWQsXG4gICAgICBpc19jb21wbGV0ZTogd2lubmVySWQgIT09IG51bGwsXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9KVxuICAgIC5lcSgnaWQnLCBnYW1lSWQpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUGxheWVyc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBsYXllcnNCeVBvb2wocG9vbElkOiBzdHJpbmcpOiBQcm9taXNlPFBsYXllcltdPiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BsYXllcnMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgncG9vbF9pZCcsIHBvb2xJZClcbiAgICAub3JkZXIoJ2xpdmVzX3JlbWFpbmluZycsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgIC5vcmRlcignZGlzcGxheV9uYW1lJyk7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXJQbGF5ZXIocG9vbElkOiBzdHJpbmcpOiBQcm9taXNlPFBsYXllciB8IG51bGw+IHtcbiAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gIFxuICBpZiAoIXVzZXIpIHJldHVybiBudWxsO1xuICBcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncGxheWVycycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdwb29sX2lkJywgcG9vbElkKVxuICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgLnNpbmdsZSgpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhO1xufVxuXG4vLyBQaWNrc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBpY2tzQnlQbGF5ZXIocGxheWVySWQ6IHN0cmluZyk6IFByb21pc2U8UGlja1tdPiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BpY2tzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ3BsYXllcl9pZCcsIHBsYXllcklkKVxuICAgIC5vcmRlcignd2Vla19udW1iZXInKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBcbiAgcmV0dXJuIGRhdGEgfHwgW107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJtaXRQaWNrKHBpY2s6IE9taXQ8UGljaywgJ2lkJyB8ICdjcmVhdGVkX2F0JyB8ICd1cGRhdGVkX2F0Jz4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncGlja3MnKVxuICAgIC5pbnNlcnQocGljayk7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBVcGRhdGUgZXhpc3RpbmcgcGlja1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBpY2socGxheWVySWQ6IHN0cmluZywgd2Vla051bWJlcjogbnVtYmVyLCB0ZWFtSWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdwaWNrcycpXG4gICAgLnVwZGF0ZSh7IFxuICAgICAgdGVhbV9pZDogdGVhbUlkLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfSlcbiAgICAuZXEoJ3BsYXllcl9pZCcsIHBsYXllcklkKVxuICAgIC5lcSgnd2Vla19udW1iZXInLCB3ZWVrTnVtYmVyKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEdldCBleGlzdGluZyBwaWNrIGZvciBhIHBsYXllciBhbmQgd2Vla1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEV4aXN0aW5nUGljayhwbGF5ZXJJZDogc3RyaW5nLCB3ZWVrTnVtYmVyOiBudW1iZXIpOiBQcm9taXNlPFBpY2sgfCBudWxsPiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BpY2tzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ3BsYXllcl9pZCcsIHBsYXllcklkKVxuICAgIC5lcSgnd2Vla19udW1iZXInLCB3ZWVrTnVtYmVyKVxuICAgIC5zaW5nbGUoKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gQ2hlY2sgaWYgcGlja3MgY2FuIHN0aWxsIGJlIGVkaXRlZCAoYmVmb3JlIGZpcnN0IGdhbWUgb2Ygd2VlayBzdGFydHMpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FuRWRpdFBpY2tzKHdlZWtOdW1iZXI6IG51bWJlciwgc2Vhc29uID0gMjAyNSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdnYW1lcycpXG4gICAgLnNlbGVjdCgnZ2FtZV90aW1lJylcbiAgICAuZXEoJ3NlYXNvbicsIHNlYXNvbilcbiAgICAuZXEoJ3dlZWtfbnVtYmVyJywgd2Vla051bWJlcilcbiAgICAub3JkZXIoJ2dhbWVfdGltZScpXG4gICAgLmxpbWl0KDEpXG4gICAgLnNpbmdsZSgpO1xuICBcbiAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICBjb25zdCBmaXJzdEdhbWVUaW1lID0gbmV3IERhdGUoZGF0YS5nYW1lX3RpbWUpO1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICBcbiAgcmV0dXJuIG5vdyA8IGZpcnN0R2FtZVRpbWU7XG59XG5cbi8vIFBvb2xzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdFBvb2woKTogUHJvbWlzZTxQb29sIHwgbnVsbD4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdwb29scycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgIC5saW1pdCgxKVxuICAgIC5zaW5nbGUoKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVBsYXllckZvckN1cnJlbnRVc2VyKHBvb2xJZDogc3RyaW5nLCBkaXNwbGF5TmFtZT86IHN0cmluZyk6IFByb21pc2U8UGxheWVyIHwgbnVsbD4ge1xuICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgXG4gIGlmICghdXNlcikgcmV0dXJuIG51bGw7XG4gIFxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdwbGF5ZXJzJylcbiAgICAuaW5zZXJ0KHtcbiAgICAgIHBvb2xfaWQ6IHBvb2xJZCxcbiAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICBkaXNwbGF5X25hbWU6IGRpc3BsYXlOYW1lIHx8IHVzZXIuZW1haWw/LnNwbGl0KCdAJylbMF0gfHwgJ1BsYXllcicsXG4gICAgICBsaXZlc19yZW1haW5pbmc6IDMsXG4gICAgICBpc19lbGltaW5hdGVkOiBmYWxzZSxcbiAgICB9KVxuICAgIC5zZWxlY3QoKVxuICAgIC5zaW5nbGUoKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gQXZhaWxhYmxlIHRlYW1zIGZvciBhIHBsYXllciAodGVhbXMgbm90IHlldCB1c2VkKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEF2YWlsYWJsZVRlYW1zKHBsYXllcklkOiBzdHJpbmcpOiBQcm9taXNlPFRlYW1bXT4ge1xuICAvLyBHZXQgYWxsIHRlYW1zXG4gIGNvbnN0IGFsbFRlYW1zID0gYXdhaXQgZ2V0QWxsVGVhbXMoKTtcbiAgXG4gIC8vIEdldCBwbGF5ZXIncyBwaWNrc1xuICBjb25zdCBwaWNrcyA9IGF3YWl0IGdldFBpY2tzQnlQbGF5ZXIocGxheWVySWQpO1xuICBjb25zdCB1c2VkVGVhbUlkcyA9IHBpY2tzLm1hcChwaWNrID0+IHBpY2sudGVhbV9pZCk7XG4gIFxuICAvLyBGaWx0ZXIgb3V0IHVzZWQgdGVhbXNcbiAgcmV0dXJuIGFsbFRlYW1zLmZpbHRlcih0ZWFtID0+ICF1c2VkVGVhbUlkcy5pbmNsdWRlcyh0ZWFtLmlkKSk7XG59Il0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlIiwiZ2V0QWxsVGVhbXMiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJnZXRHYW1lc0J5V2VlayIsIndlZWsiLCJzZWFzb24iLCJlcSIsInVwZGF0ZUdhbWVXaW5uZXIiLCJnYW1lSWQiLCJ3aW5uZXJJZCIsInVwZGF0ZSIsIndpbm5lciIsImlzX2NvbXBsZXRlIiwidXBkYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImdldFBsYXllcnNCeVBvb2wiLCJwb29sSWQiLCJhc2NlbmRpbmciLCJnZXRDdXJyZW50VXNlclBsYXllciIsInVzZXIiLCJhdXRoIiwiZ2V0VXNlciIsImlkIiwic2luZ2xlIiwiZ2V0UGlja3NCeVBsYXllciIsInBsYXllcklkIiwic3VibWl0UGljayIsInBpY2siLCJpbnNlcnQiLCJ1cGRhdGVQaWNrIiwid2Vla051bWJlciIsInRlYW1JZCIsInRlYW1faWQiLCJnZXRFeGlzdGluZ1BpY2siLCJjYW5FZGl0UGlja3MiLCJsaW1pdCIsImZpcnN0R2FtZVRpbWUiLCJnYW1lX3RpbWUiLCJub3ciLCJnZXREZWZhdWx0UG9vbCIsImNyZWF0ZVBsYXllckZvckN1cnJlbnRVc2VyIiwiZGlzcGxheU5hbWUiLCJwb29sX2lkIiwidXNlcl9pZCIsImRpc3BsYXlfbmFtZSIsImVtYWlsIiwic3BsaXQiLCJsaXZlc19yZW1haW5pbmciLCJpc19lbGltaW5hdGVkIiwiZ2V0QXZhaWxhYmxlVGVhbXMiLCJhbGxUZWFtcyIsInBpY2tzIiwidXNlZFRlYW1JZHMiLCJtYXAiLCJmaWx0ZXIiLCJ0ZWFtIiwiaW5jbHVkZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/supabaseQueries.ts\n"));

/***/ })

});